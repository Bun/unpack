#!/usr/bin/env python
# coding: utf-8
# BSD License (cf. COPYING)

from optparse import OptionParser

import subprocess
import re
import os

import zipfile
import tarfile


class Unzip(object):
    def __init__(self, filename):
        self.filename = filename
        self.zip = zipfile.ZipFile(filename, 'r')


    def files(self):
        return (f.filename for f in self.zip.infolist())


    def unpack(self, path):
        for f in self.zip.infolist():
            self.zip.extract(f, path)


class Untar(object):
    def __init__(self, filename):
        self.filename = filename
        self.tar = tarfile.open(filename, 'r')


    def files(self):
        for f in self.tar.getmembers():
            if f.isdir():
                yield f.name + '/'
            else:
                yield f.name


    def unpack(self, path):
        self.tar.extractall(path)


#
# Commandline based unpackers
#
makeCommand = lambda cline, **kw: [arg % kw for arg in cline]


def command_run(cmd, pipe=False):
    verbose('Running: %s' % (cmd,))
    params = {}

    if pipe:
        params['stdout'] = subprocess.PIPE

    return subprocess.Popen(cmd, **params)


class UnpackGeneric(object):
    _unpack = None
    _lines = None


    def __init__(self, filename):
        self.filename = filename


    def files(self):
        cmd = command_run(makeCommand(self._lines.split(), file=self.filename),
            pipe=True)
        stdout, _ = cmd.communicate()
        cmd.wait()

        if cmd.returncode:
            raise ValueError, 'command returned %d' % (cmd.returncode,)

        return self._parse(stdout.split('\n'))


    def unpack(self, path):
        cmd = command_run(makeCommand(self._unpack.split(),
            file=self.filename, dir=path))
        cmd.wait()

        if cmd.returncode:
            raise ValueError, 'command returned %d' % (cmd.returncode,)


    def _parse(self, lines):
        raise NotImplementedError


class UnpackP7Zip(UnpackGeneric):
    _unpack = '7z x -o%(dir)s -bd -- %(file)s'
    _lines = '7z l -slt -- %(file)s'


    def _parse(self, lines):
        """
        p7zip output are chunks separated by
        empty lines
    
        - infoChunk (copyright, version, archive info)
        - contents
        """
        infoChunk = False
        values = {}
    
        for line in lines:
            line = line.rstrip()
    
            if not infoChunk:
                # XXX: This may vary from version to version
                if line == '----------':
                    infoChunk = True
    
                continue
    
            if line == '':
                if not values:
                    continue
    
                # Only return non-directories
                if int(values['size']):
                    yield values['path']
    
                values = {}
    
            else:
                k, v = line.split('=', 1)
                # XXX: In case of directory names with a leading space,
                #  this will fail horribly.
                values[k.rstrip().lower()] = v.lstrip()
    
        assert infoChunk, 'Failed to parse p7zip output'


formats = {
    'zip': Unzip,
    '7z': UnpackP7Zip,
    'tar': Untar,
}

alias = {
    'rar': '7z',
    'cab': '7z',
    'tgz': 'tar',
}


#
# CLI
#

def warn(msg):
    print msg


def verbose(msg):
    if options.verbose:
        print msg


def topdir_extract(files):
    """ Given a set of files, find the common parent directory """
    topdir = False
    first = True

    for file in files:
        file = file.lstrip('/')

        if first:
            first = False

            if '/' in file:
                dirs = file.split('/')
                topdir = dirs[0] + '/'

            else:
                return False

        # Verify
        if not file.startswith(topdir):
            return False

    return topdir


def format_detect(filename):
    scan = filename.split('/')[-1].split('.')
    assert len(scan) > 1
    scan.reverse()

    # Don't test anything but the last two extensions
    for i, ext in enumerate(scan[:2]):
        ext_lwr = ext.lower()
        ext_lwr = alias.get(ext_lwr, ext_lwr)

        if ext_lwr in formats:
            archive = '.'.join(reversed(scan[i+1:]))
            return archive, formats[ext_lwr]

    return None, False


if __name__ == '__main__':
    parser = OptionParser()
    parser.add_option('-n', '--dry-run', dest='dry_run',
                        action='store_true',
                        default=False,
                        help='do not unpack archive')
    parser.add_option('-v', '--verbose', dest='verbose',
                        action='store_true',
                        default=False,
                        help='verbose output')
    options, args = parser.parse_args()

    if not args:
        parser.print_help()
        exit()

    for file in args:
        archive, fmt = format_detect(file)
        assert fmt, 'Unsupported file format'
        unpacker = fmt(file)
        topdir = topdir_extract(unpacker.files())

        if topdir is not False:
            if os.path.exists(topdir):
                warn('%r already exists!' % (topdir,))
                raise Exception

            path = '.'
            verbose('Archive has valid topdir %r' % (topdir, ))

        else:
            path = archive
            verbose('Using %r as topdir' % (path, ))

            if os.path.exists(path):
                warn('%r already exists!' % (path,))
                raise Exception

        verbose('Unpacking to %r' % (path,))

        if not options.dry_run:
            unpacker.unpack(path)

