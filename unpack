#!/usr/bin/env python
# coding: utf-8
# BSD License (cf. COPYING)

from optparse import OptionParser

import os
import re
import subprocess
import tarfile
import tempfile
import zipfile


def unzip(archive, path):
    zf = zipfile.ZipFile(archive, 'r')

    for fname in zf.infolist():
        zf.extract(fname, path)


def untar(archive, path):
    tf = tarfile.open(archive, 'r')
    tf.extractall(path)


def untar_cl(archive, path):
    subprocess.check_call(('tar',  'xf', archive, '-C', path))


def un7zip(archive, path):
    subprocess.check_call(('7z',  'x', '-o' + path, '-bd', '--', archive))


formats = (
    ('.zip', unzip),
    ('.jar', unzip),

    # Python untar
    ('.tar', untar),
    ('.tgz', untar),
    ('.tar.gz', untar),
    ('.tar.bz2', untar),

    # System untar
    ('.tar.lzma', untar_cl),

    ('.7z', un7zip),
    ('.rar', un7zip),
    ('.cab', un7zip),

    #('.gz', ungz),
    #('.bz2', unbzip2),
    #('.lzma', unlzma),
)


def format_detect(filename):
    ''' Determine the unpack function by checking the extension '''
    scan = filename.lower()

    for ext, unpacker in formats:
        if scan.endswith(ext):
            archive_name = os.path.basename(filename)[:-len(ext)]
            return archive_name, unpacker

    return None, False


def unpack(filename, options):
    path = options.directory or '.'

    # Determine archive type
    archive_name, unpacker = format_detect(filename)
    assert unpacker, 'Unsupported file format'

    # Unpack that stuff
    temporary_path = tempfile.mkdtemp(prefix='.unpack', dir=path)

    if options.verbose:
        print('Extracting to {}'.format(temporary_path))

    unpacker(filename, temporary_path)

    # Figure out directory name
    archive_files = os.listdir(temporary_path)

    if len(archive_files) == 1:
        file_path = os.path.join(temporary_path, archive_files[0])

        if not os.path.isdir(file_path) and not options.force_directory:
            # Archive is a single file
            target = os.path.join(path, archive_files[0])

            if os.path.exists(target):
                raise ValueError, 'Refusing to overwrite %r' % (target,)

            os.rename(file_path, target)
            os.rmdir(temporary_path)
            return

        # Archive has a single top directory
        source = file_path

        if options.basename is not None:
            target = os.path.join(path, options.basename)
            unlink_temp = False

        else:
            target = os.path.join(path, archive_files[0])
            unlink_temp = True

    else:
        assert options.basename is None, 'TODO'
        assert archive_name, 'No archive name'

        # Archive has multiple files, but no common parent directory
        source = temporary_path
        target = os.path.join(path, archive_name)
        unlink_temp = False

    if options.verbose:
        print('Renaming {} to {}'.format(source, target))
    else:
        print('Extracted {} to {}'.format(filename, target))

    if os.path.exists(target):
        # TODO: option to clean up temporary_path
        print('!!! Refusing to overwrite {}'.format(target))
        print('!!! Unpacked to {}'.format(temporary_path))
        return

    os.rename(source, target)

    if unlink_temp:
        os.rmdir(temporary_path)


if __name__ == '__main__':
    parser = OptionParser()

    parser.add_option('-v', '--verbose',
        dest='verbose',
        action='store_true',
        default=False,
        help='verbose output')

    parser.add_option('-x', '--force-directory',
        dest='force_directory',
        action='store_true',
        default=False,
        help='always extract files to a directory, even for single file archives')

    parser.add_option('-p', '--path', metavar='DIRECTORY',
        dest='directory',
        default=None,
        help='unpack in directory (default: .)')

    parser.add_option('-d', '--directory', metavar='DIRECTORY',
        dest='basename',
        default=None,
        help='override archive base path')

    options, args = parser.parse_args()

    if not args:
        parser.print_help()
        exit()

    for filename in args:
        unpack(filename, options)
